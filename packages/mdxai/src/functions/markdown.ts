import { generateText } from 'ai'
import { model } from '../ai'
import { unified } from 'unified'
import remarkParse from 'remark-parse'
import { parseTemplate } from '../utils/template.js'

/**
 * Markdown template literal function for generating markdown content with AI
 *
 * Usage: await markdown`Write a guide about ${topic}`
 */
export type MarkdownTemplateFn = (template: TemplateStringsArray, ...values: any[]) => Promise<MarkdownResult>

/**
 * Result object containing both raw markdown and parsed AST
 */
export interface MarkdownResult {
  /** Raw markdown string generated by AI */
  markdown: string
  /** Parsed markdown AST (MDAST) */
  mdast: any
}

/**
 * Core markdown function that takes a prompt and returns markdown with AST
 */
async function markdownCore(prompt: string): Promise<MarkdownResult> {
  const result = await generateText({
    model: model('gpt-4o'),
    system: 'You are a helpful assistant that responds in well-formatted markdown. Use proper markdown syntax including headers, lists, code blocks, links, and other formatting as appropriate for the content.',
    prompt,
  })

  const markdown = result.text

  // Parse the markdown into an AST using unified and remark-parse
  const processor = unified().use(remarkParse)
  const mdast = processor.parse(markdown)

  return {
    markdown,
    mdast,
  }
}

// Create a function that supports both string parameters and template literals
function markdownFunction(promptOrTemplate: string | TemplateStringsArray, ...values: any[]): Promise<MarkdownResult> {
  // If first argument is a string, use the original interface
  if (typeof promptOrTemplate === 'string') {
    return markdownCore(promptOrTemplate)
  }
  
  // If first argument is a TemplateStringsArray, use template literal interface
  if (Array.isArray(promptOrTemplate) && 'raw' in promptOrTemplate) {
    const prompt = parseTemplate(promptOrTemplate as TemplateStringsArray, values)
    return markdownCore(prompt)
  }
  
  throw new Error('Markdown function must be called with a string or as a template literal')
}

export const markdown = new Proxy(markdownFunction, {
  get(target, prop) {
    if (prop === 'then' || prop === 'catch' || prop === 'finally') {
      return undefined
    }

    if (typeof prop === 'symbol') {
      return Reflect.get(target, prop)
    }

    return target
  },

  apply(target, thisArg, args: any[]) {
    const [first, ...rest] = args
    return target(first, ...rest)
  },
}) 