/**
 * @mdxe/esbuild
 *
 * An esbuild plugin that processes MDX files and exports them with frontmatter,
 * raw markdown content, and compiled React components.
 */

import fs from 'node:fs'
import path from 'node:path'
import fg from 'fast-glob'
import * as esbuild from 'esbuild'
import mdxPlugin from '@mdx-js/esbuild'
import remarkFrontmatter from 'remark-frontmatter'
import remarkMdxFrontmatter from 'remark-mdx-frontmatter'
import remarkGfm from 'remark-gfm'
import { unified } from 'unified'
import remarkParse from 'remark-parse'
import remarkMdx from 'remark-mdx'
import { visit } from 'unist-util-visit'
import { MdxeBuildOptions, CodeBlock, EnhancedCodeBlock } from './types'
import { analyzeCodeBlock, toCamelCase } from './ast-utils'

/**
 * Converts a file path to a TitleCase key
 *
 * @example
 * toTitleCase('path/to/my-file.mdx') // 'PathToMyFile'
 */
function toTitleCase(filePath: string): string {
  return filePath
    .replace(/\.[^/.]+$/, '') // strip extension
    .split(/[^a-zA-Z0-9]+/) // split on non-alphanum
    .filter(Boolean)
    .map((w) => w[0].toUpperCase() + w.slice(1))
    .join('')
}

/**
 * Extract code blocks from MDX content with section tracking
 */
function extractCodeBlocksWithSections(mdxContent: string): EnhancedCodeBlock[] {
  const codeBlocks: EnhancedCodeBlock[] = []
  let currentSection: string | undefined

  const tree = unified().use(remarkParse).use(remarkMdx).parse(mdxContent)

  visit(tree, ['heading', 'code'], (node: any) => {
    if (node.type === 'heading') {
      currentSection = node.children?.map((child: any) => child.value || '').join('') || ''
    } else if (node.type === 'code') {
      codeBlocks.push({
        lang: node.lang || '',
        meta: node.meta || null,
        value: node.value || '',
        type: 'statement',
        parentSection: currentSection,
        isExported: false,
      })
    }
  })

  return codeBlocks
}

/**
 * Extract code blocks from MDX content (legacy function for backward compatibility)
 */
function extractCodeBlocks(mdxContent: string): CodeBlock[] {
  const codeBlocks: CodeBlock[] = []

  const tree = unified().use(remarkParse).use(remarkMdx).parse(mdxContent)

  visit(tree, 'code', (node: any) => {
    codeBlocks.push({
      lang: node.lang || '',
      meta: node.meta || null,
      value: node.value || '',
    })
  })

  return codeBlocks
}

/**
 * Filter code blocks by type (executable vs test) with enhanced analysis
 */
function categorizeCodeBlocks(codeBlocks: CodeBlock[]): {
  executableBlocks: CodeBlock[]
  testBlocks: CodeBlock[]
} {
  const executableBlocks: CodeBlock[] = []
  const testBlocks: CodeBlock[] = []

  codeBlocks.forEach((block) => {
    // Only process TypeScript/JavaScript blocks
    if (!['typescript', 'ts', 'javascript', 'js', 'tsx', 'jsx'].includes(block.lang)) {
      return
    }

    // Check if it's a test block
    if (block.meta?.includes('test')) {
      testBlocks.push(block)
    } else if (block.meta?.includes('exec') || block.meta?.includes('execute') || !block.meta) {
      // Include blocks marked as exec/execute or blocks without meta (default to executable)
      executableBlocks.push(block)
    }
  })

  return { executableBlocks, testBlocks }
}

/**
 * Enhanced categorization with AST analysis
 */
function categorizeEnhancedCodeBlocks(codeBlocks: EnhancedCodeBlock[]): {
  executableBlocks: EnhancedCodeBlock[]
  testBlocks: EnhancedCodeBlock[]
} {
  const executableBlocks: EnhancedCodeBlock[] = []
  const testBlocks: EnhancedCodeBlock[] = []

  codeBlocks.forEach((block) => {
    // Only process TypeScript/JavaScript blocks
    if (!['typescript', 'ts', 'javascript', 'js', 'tsx', 'jsx'].includes(block.lang)) {
      return
    }

    const analyzedBlock = analyzeCodeBlock(block)

    // Check if it's a test block
    if (analyzedBlock.meta?.includes('test')) {
      testBlocks.push(analyzedBlock)
    } else if (analyzedBlock.meta?.includes('exec') || analyzedBlock.meta?.includes('execute') || !analyzedBlock.meta) {
      // Include blocks marked as exec/execute or blocks without meta (default to executable)
      executableBlocks.push(analyzedBlock)
    }
  })

  return { executableBlocks, testBlocks }
}

/**
 * Generates the source code for the temporary index file
 */
function generateIndexSource(contentDir: string, entries: string[], shouldExtractCodeBlocks: boolean = false): string {
  let indexSource = ''
  indexSource += `// ⚠️ Auto-generated by @mdxe/esbuild\n\n`

  // Import all MDX files
  entries.forEach((rel, i) => {
    const abs = path.join(contentDir, rel)
    const id = `mod${i}`
    indexSource += `import * as ${id} from '${abs.replace(/\\/g, '/')}';\n`
  })

  if (shouldExtractCodeBlocks) {
    entries.forEach((rel, i) => {
      const content = fs.readFileSync(path.join(contentDir, rel), 'utf8')
      const allCodeBlocks = extractCodeBlocksWithSections(content)
      const { executableBlocks } = categorizeEnhancedCodeBlocks(allCodeBlocks)

      executableBlocks.forEach((block) => {
        if (block.type === 'declaration' || block.type === 'mixed') {
          if (!block.isExported && block.declarations && block.declarations.length > 0) {
            indexSource += `\n// Exported from ${rel}\n`
            indexSource += `${block.value}\n`
            block.declarations.forEach((name) => {
              indexSource += `export { ${name} };\n`
            })
          }
        }
      })

      executableBlocks.forEach((block, blockIndex) => {
        if (block.type === 'statement' || block.type === 'mixed') {
          if (block.parentSection) {
            const functionName = toCamelCase(block.parentSection)
            indexSource += `\n// Statement from "${block.parentSection}" in ${rel}\n`
            indexSource += `export function ${functionName}() {\n`
            indexSource += `  ${block.value.replace(/\n/g, '\n  ')}\n`
            indexSource += `}\n`
          } else {
            const functionName = `executeBlock${blockIndex}`
            indexSource += `\n// Statement block in ${rel}\n`
            indexSource += `export function ${functionName}() {\n`
            indexSource += `  ${block.value.replace(/\n/g, '\n  ')}\n`
            indexSource += `}\n`
          }
        }
      })
    })
  }

  // Export a default object with all MDX content
  indexSource += `\nexport default {\n`
  entries.forEach((rel, i) => {
    const key = toTitleCase(rel)
    const id = `mod${i}`
    // Read raw markdown
    const raw = JSON.stringify(fs.readFileSync(path.join(contentDir, rel), 'utf8'))

    if (shouldExtractCodeBlocks) {
      // Extract and categorize code blocks with enhanced analysis
      const content = fs.readFileSync(path.join(contentDir, rel), 'utf8')
      const allCodeBlocks = extractCodeBlocksWithSections(content)
      const { executableBlocks, testBlocks } = categorizeEnhancedCodeBlocks(allCodeBlocks)

      indexSource += `  ${key}: { 
        ...${id}, 
        markdown: ${raw},
        code: ${JSON.stringify(executableBlocks)},
        test: ${JSON.stringify(testBlocks)}
      },\n`
    } else {
      indexSource += `  ${key}: { ...${id}, markdown: ${raw} },\n`
    }
  })
  indexSource += `};\n`

  return indexSource
}

/**
 * Discovers MDX files in a directory
 */
async function findMdxFiles(dir: string): Promise<string[]> {
  try {
    const files = await fg(['**/*.md', '**/*.mdx'], {
      cwd: dir,
      absolute: false, // Return relative paths
    })

    const filteredFiles = files.filter((file) => {
      return !file.includes('/node_modules/') && !file.includes('/dist/') && !file.includes('/build/') && !file.includes('/.git/')
    })

    return filteredFiles
  } catch (error) {
    console.error('Error finding MDX files:', error)
    return []
  }
}

/**
 * Builds MDX content into a single ESM bundle
 */
async function buildMdxContent(options: MdxeBuildOptions = {}): Promise<void> {
  const {
    contentDir = path.resolve(process.cwd(), 'content'),
    outFile = path.resolve(process.cwd(), 'dist/content.mjs'),
    remarkPlugins = [],
    rehypePlugins = [],
    watch = false,
    extractCodeBlocks = true,
  } = options

  // 1. Ensure output directory exists
  fs.mkdirSync(path.dirname(outFile), { recursive: true })

  // 2. Discover all .md/.mdx files
  const entries = await findMdxFiles(contentDir)

  if (entries.length === 0) {
    console.warn(`No MDX files found in ${contentDir}`)
    return
  }

  // 3. Generate index source
  const indexSource = generateIndexSource(contentDir, entries, extractCodeBlocks)

  // 4. Write temp index
  const tmpIndex = path.resolve(path.dirname(outFile), '.tmp-content-index.js')
  fs.writeFileSync(tmpIndex, indexSource)

  // 5. Configure esbuild
  const buildOptions: esbuild.BuildOptions = {
    entryPoints: [tmpIndex],
    bundle: true,
    format: 'esm',
    outfile: outFile,
    plugins: [
      mdxPlugin({
        remarkPlugins: [remarkFrontmatter, [remarkMdxFrontmatter, { name: 'data' }], remarkGfm, ...remarkPlugins],
        rehypePlugins,
      }),
    ],
    external: ['react', 'react/jsx-runtime', 'react-dom', 'next', 'ink'],
  }

  try {
    if (watch) {
      // Use esbuild context for watch mode
      const ctx = await esbuild.context(buildOptions)
      await ctx.watch()
      console.log(`👀 Watching for changes in ${contentDir}...`)
      // Note: In watch mode, we don't clean up the temp file
      // since it's needed for rebuilds
    } else {
      // One-time build
      await esbuild.build(buildOptions)
      console.log(`✅ MDX bundle written to ${outFile}`)

      // Clean up temp file in non-watch mode
      if (fs.existsSync(tmpIndex)) {
        fs.unlinkSync(tmpIndex)
      }
    }
  } catch (error) {
    console.error('Error building MDX content:', error)

    // Clean up temp file on error
    if (fs.existsSync(tmpIndex) && !watch) {
      fs.unlinkSync(tmpIndex)
    }

    throw error
  }
}

/**
 * Creates an esbuild plugin for processing MDX files
 */
function mdxePlugin(options: MdxeBuildOptions = {}): esbuild.Plugin {
  return {
    name: 'mdxe',
    setup(build) {
      build.onEnd(async () => {
        try {
          await buildMdxContent(options)
        } catch (error) {
          console.error('Error in mdxe plugin:', error)
        }
      })
    },
  }
}

// Export the public API
export {
  toTitleCase,
  generateIndexSource,
  findMdxFiles,
  buildMdxContent,
  mdxePlugin,
  extractCodeBlocks,
  categorizeCodeBlocks,
  extractCodeBlocksWithSections,
  categorizeEnhancedCodeBlocks,
}

// Export types
export type { MdxContentItem, MdxContentMap, CodeBlock, EnhancedCodeBlock, MdxeBuildOptions } from './types'
